"use server";

import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { generateInvoiceNumber } from "@/lib/invoice-number";
import { getUserSettings } from "@/lib/settings";
import { sendInvoiceEmail } from "@/lib/email/send-invoice";

const invoiceItemSchema = z.object({
  description: z.string().min(1, "Description is required"),
  quantity: z.coerce.number().positive("Quantity must be positive"),
  price: z.coerce.number().positive("Price must be positive"),
});

const invoiceSchema = z.object({
  clientId: z.string().min(1, "Client is required"),
  invoiceNumber: z.string().optional(), // Now optional - will be auto-generated
  dueDate: z.string().min(1, "Due date is required"),
  items: z.array(invoiceItemSchema).min(1, "At least one item is required"),
});

export async function getInvoices(statusFilter?: InvoiceStatus | "ALL") {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  // Check for overdue invoices before fetching
  await checkOverdueInvoicesInternal(userId);

  // Build where clause with optional status filter 
  const where: { userId: string; status?: InvoiceStatus } = { userId };
  if (statusFilter && statusFilter !== "ALL") {
    where.status = statusFilter;
  }

  return await prisma.invoice.findMany({
    where,
    include: {
      client: true,
      items: true,
    },
    orderBy: { createdAt: "desc" },
  });
}

/**
 * Internal function to check overdue invoices without auth check
 * Used by getInvoices which already has auth
 */
async function checkOverdueInvoicesInternal(userId: string): Promise<number> {
  const now = new Date();
  
  const overdueInvoices = await prisma.invoice.findMany({
    where: {
      userId,
      dueDate: { lt: now },
      status: { in: ["SENT", "VIEWED"] },
    },
    select: { id: true },
  });

  if (overdueInvoices.length === 0) {
    return 0;
  }

  await prisma.invoice.updateMany({
    where: {
      id: { in: overdueInvoices.map((inv: { id: string }) => inv.id) },
    },
    data: {
      status: "OVERDUE",
    },
  });

  return overdueInvoices.length;
}

export async function getInvoice(id: string) {
  const { userId } = await auth();
  if (!userId) throw new Error("Unauthorized");

  return await prisma.invoice.findUnique({
    where: { id, userId },
    include: {
      client: true,
      items: true,
    },
  });
}

export async function createInvoice(prevState: any, formData: FormData) {
  const { userId } = await auth();
  if (!userId) return { message: "Unauthorized" };

  // Parse the form data
  const data: any = {};
  const items: any[] = [];
  
  formData.forEach((value, key) => {
    if (key.startsWith("items[")) {
      const match = key.match(/items\[(\d+)\]\.(\w+)/);
      if (match) {
        const index = parseInt(match[1]);
        const field = match[2];
        if (!items[index]) items[index] = {};
        items[index][field] = value;
      }
    } else {
      data[key] = value;
    }
  });

  data.items = items;

  const parsed = invoiceSchema.safeParse(data);

  if (!parsed.success) {
    return { message: "Invalid data", errors: parsed.error.flatten().fieldErrors };
  }

  // Verify client belongs to user
  const client = await prisma.client.findUnique({
    where: { id: parsed.data.clientId, userId },
  });

  if (!client) {
    return { message: "Invalid client" };
  }

  // Calculate total
  const totalAmount = parsed.data.items.reduce((sum, item) => {
    return sum + (item.quantity * item.price);
  }, 0);

  try {
    // Get user settings for invoice prefix and currency
    const settings = await getUserSettings(userId);
    
    // Auto-generate invoice number using user's prefix
    const invoiceNumber = await generateInvoiceNumber(userId, settings.invoicePrefix);

    await prisma.invoice.create({
      data: {
        userId,
        clientId: parsed.data.clientId,
        invoiceNumber,
        status: "DRAFT", // Always start as DRAFT 
        dueDate: new Date(parsed.data.dueDate),
        totalAmount,
        currency: settings.currency, // Use user's default currency
        // publicToken is auto-generated by Prisma schema default
        items: {
          create: parsed.data.items.map(item => ({
            description: item.description,
            quantity: item.quantity,
            price: item.price,
            amount: item.quantity * item.price,
          })),
        },
      },
    });
    revalidatePath("/invoices");
    return { message: "Invoice created", success: true };
  } catch (e) {
    console.error(e);
    return { message: "Failed to create invoice" };
  }
}

export type InvoiceStatus = "DRAFT" | "SENT" | "VIEWED" | "PAID" | "OVERDUE" | "VOID";

export async function updateInvoiceStatus(
  id: string, 
  status: InvoiceStatus,
  paymentMethod?: "stripe" | "manual"
) {
  const { userId } = await auth();
  if (!userId) return { message: "Unauthorized" };

  // Verify invoice belongs to user
  const invoice = await prisma.invoice.findUnique({
    where: { id, userId },
  });

  if (!invoice) {
    return { message: "Invoice not found" };
  }

  try {
    // Build update data with appropriate timestamps based on status
    const updateData: {
      status: InvoiceStatus;
      sentAt?: Date;
      viewedAt?: Date;
      paidAt?: Date;
      paymentMethod?: string;
    } = { status };

    const now = new Date();

    // Set timestamps based on status transition 
    switch (status) {
      case "SENT":
        updateData.sentAt = now;
        break;
      case "VIEWED":
        updateData.viewedAt = now;
        break;
      case "PAID":
        updateData.paidAt = now;
        if (paymentMethod) {
          updateData.paymentMethod = paymentMethod;
        }
        break;
    }

    await prisma.invoice.update({
      where: { id },
      data: updateData,
    });
    revalidatePath("/invoices");
    return { message: "Invoice status updated", success: true };
  } catch (e) {
    console.error(e);
    return { message: "Failed to update invoice" };
  }
}

export async function deleteInvoice(id: string) {
  const { userId } = await auth();
  if (!userId) return { message: "Unauthorized" };

  // Verify invoice belongs to user
  const invoice = await prisma.invoice.findUnique({
    where: { id, userId },
  });

  if (!invoice) {
    return { message: "Invoice not found" };
  }

  try {
    await prisma.invoice.delete({
      where: { id },
    });
    revalidatePath("/invoices");
    return { message: "Invoice deleted", success: true };
  } catch (e) {
    return { message: "Failed to delete invoice" };
  }
}

/**
 * Checks for overdue invoices and updates their status to OVERDUE
 * An invoice is overdue if:
 * - Due date is in the past
 * - Status is SENT or VIEWED (not DRAFT, PAID, or VOID)
 * 
 */
export async function checkOverdueInvoices(userId: string): Promise<number> {
  return checkOverdueInvoicesInternal(userId);
}

/**
 * Utility function to calculate days overdue for an invoice
 */
export async function calculateDaysOverdue(dueDate: Date): Promise<number> {
  const now = new Date();
  const diffTime = now.getTime() - dueDate.getTime();
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  return Math.max(0, diffDays);
}

/**
 * Send invoice via email
 * 
 */
export async function sendInvoice(
  invoiceId: string,
  options?: { subject?: string; message?: string }
) {
  const { userId } = await auth();
  if (!userId) return { message: "Unauthorized", success: false };

  // Fetch invoice to get client email
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId, userId },
    include: { client: true },
  });

  if (!invoice) {
    return { message: "Invoice not found", success: false };
  }

  if (!invoice.client.email) {
    return { message: "Client does not have an email address", success: false };
  }

  // Send the email
  const result = await sendInvoiceEmail({
    invoiceId,
    userId,
    to: invoice.client.email,
    subject: options?.subject,
    message: options?.message,
  });

  if (result.success) {
    revalidatePath("/invoices");
    return { message: "Invoice sent successfully", success: true };
  }

  return { message: result.error || "Failed to send invoice", success: false };
}
